#include <msp430.h> 

/****** Separate timer/Interrupt to ensure flash control is halting and restarting other processes ******/
    volatile unsigned int timerTick125 = 0;
    void setupTimerA1(void) // 125us timer counter
    {
        BCSCTL1 = (CALBC1_8MHZ);
        DCOCTL  = (CALDCO_8MHZ);
        BCSCTL2 = (SELM_0);                   // Selects DCO for SMCLK & MCLK

        TA1CCR0 = 1000;                       // Timer period register,   1000 / 8MHZ = 125us
        TA1CTL |= (TASSEL_2 + TACLR + MC_1);  // SMCLK, clear timer, count-up mode: Count up to CCR0 and reset
        TA1CCTL0 = CCIE;                      // Enable Timer1 CCR0 interrupt
        __bis_SR_register(GIE);               // Enable global interrupt
    }
    #pragma vector=TIMER1_A0_VECTOR
    __interrupt void Timer1_A1_ISR(void)
    {
        timerTick125++; // Incremented every 125us
    }
/**********************************************************/

#define FLASH_SECTOR_B  (0x1080)    // Address of flash sector B
#define FLASH_SECTOR_C  (0x1040)    // Address of flash sector C
#define FLASH_SECTOR_D  (0x1000)    // Address of flash sector D

#define DATA_NUM_BYTES 8

int presetFreq[] = {200, 400, 600, 800};    // Starting point, values are written into flash and then stored into 'finalArray[]'
int finalArray[] = {1, 2, 3, 4};            // Ending point, final values should be read from memory and updated with presetFreq[] values

typedef enum
{
    NO_ERROR = 0,
    ERROR
} FlashError;   // Flash error status

FlashError setupFlash(void) // This routine sets up for a flash erase/write. The watchdog is turned off, the DCO is set to 1MHz, and the flash timing generator is set
{
    FlashError flashError = NO_ERROR;         // Assume no flash error
    WDTCTL = WDTPW + WDTHOLD;                 // Stop watchdog timer

    if (CALBC1_1MHZ == 0xFF || CALDCO_1MHZ == 0xFF)
    {
        flashError = ERROR;                   // Clock values bad
    }
    else
    {
        // No error, set the clock
        BCSCTL1 = CALBC1_1MHZ;
        DCOCTL = CALDCO_1MHZ;
        FCTL2 = FWKEY + FSSEL0 + FN1;         // MCLK/3 for Flash Timing Generator
    }
    return (flashError);
}

void startWriteFlash(unsigned int blockAddress) // This routine starts a write cycle for a data block. It erases the block, then sets the write flag to start writing
{
    unsigned char *eraseByte;                     // Pointer used to erase blocks
    eraseByte = (unsigned char *)blockAddress;    // Initialize Flash pointer
    FCTL3 = FWKEY + LOCKA;                      // Clear B,C,D Lock bit, keep Lock A
    FCTL1 = FWKEY + ERASE;                      // Set Erase bit
    *eraseByte = 0;                               // Dummy write to erase Flash seg
    FCTL1 = FWKEY + WRT;                        // Set WRT bit for write operation
}

void flashWrite(void) // This routine saves the data to flash. This can cover flash block B and C
{
    unsigned char *ramByte;
    unsigned char *flashByte;
    unsigned int blockAddress;
    unsigned char byteCount;
    FlashError flashError = NO_ERROR;   // Assume no error yet

    TA0CCTL0 = 0;   // Halts timer interrupts
    TA1CCTL0 = 0;
    flashError = setupFlash();  // Setup flash and check for error

    if (flashError == NO_ERROR)
    {
        blockAddress = FLASH_SECTOR_B;                      // Set address to use flash sector B for config
        startWriteFlash(blockAddress);                      // Start block write
        ramByte = (unsigned char*) &presetFreq[0];                   // Initializes ramByte to hold address of data in ram   *ramByte = 100
        flashByte = (unsigned char*) blockAddress;          // Initializes flashByte to hold address of where data will go in flash

        for (byteCount = 0; byteCount < DATA_NUM_BYTES; byteCount++)    // Where the writing takes place
        {
            *flashByte = *ramByte;                   // Copies data at the address of 'ramByte' into the address for 'flashByte' which was just set as the block address in flash
            flashByte++;                             // Increment the flash address, *flashByte where the next bit of data is stored
            ramByte++;                               // Increment the data address,  *ramByte is where the next bit of data is copied from
        }

        FCTL1 = FWKEY;                               // Clear WRT bit
        FCTL3 = FWKEY + LOCK + LOCKA;                // Set all LOCK bits
    }

    TA1CCTL0 |= CCIE;    // Re-enable main system ticker interrupts
    TA0CCTL0 |= CCIE;
    setupTimerA1();    // Set clock back
}

void flashLoad(void)    // This routine loads the data from flash.
{
    unsigned char *ramByte;          // Pointer for data in RAM
    unsigned char *flashByte;        // Pointer for data in Flash
    unsigned char byteCount;

    flashByte = (unsigned char *) FLASH_SECTOR_B;       // Set address to start of block B in flash, where the data will be read from
    ramByte = (unsigned char*) &finalArray[0];                   // Set pointer to beginning of where data will go in ram from flash

    for (byteCount = 0; byteCount < DATA_NUM_BYTES; byteCount++)
    {
        *ramByte = *flashByte;                          // Get the current byte from flash
        ramByte++;                                      // Increment the data pointer
        flashByte++;                                    // Increment the flash pointer
    }
}

int main(void)
{
	WDTCTL = WDTPW | WDTHOLD;
	setupTimerA1();

	flashWrite();
    flashLoad();
}


/*

checkSum code

static unsigned int calcCheckSum = 0;        // Recalculated checkSum value to compare against the checkSum calculated when data is written to flash
static unsigned int savedCheckSum;           // Saved checksum value

unsigned int checkSum = 0;  // Local checkSum variable inside saveData

checkSum += *ramByte;                    // Calculate checkSum, goes inside write for()


Code goes between write for() and resetting lock bits
        // Save checksum
        ramByte = (unsigned char*) &checkSum;        // Sets ramByte to the calculated checkSum value
        *flashByte = *ramByte;                       // Assigns flash address (One location after data stored)
        savedCheckSum = *ramByte;                    // Saves checkSum that was just calculated for later checking


Code goes after restarting the timer
    // Now verify checksum
    flashByte = (unsigned char *) FLASH_SECTOR_B;    // Set address to use flash sector B for first stat data structure
    calcCheckSum = 0;   // Clear calcCheckSum value

    for (byteCount = 0; byteCount < DATA_NUM_BYTES; byteCount++)
    {
        calcCheckSum += *flashByte;                // Recalculates the checkSum of the data, should be the same as the value stored in savedCheckSum.
        flashByte++;
    }
    if (calcCheckSum != savedCheckSum)      // Compares first checkSum value (Calculated when data is written) and second checkSum value (Calculated when double checked above)
    {
        setDefaults();  // If checkSum values aren't the same reset test to default
    }



void setDefaults(void)  // This routine sets back to defaults if checkSum check fails
{
    bufferStoredInFlash = 64;
}



 */
