//Ethan Van Deusen
//Button and debouncing test program

//The code should toggle the D6 red LED when the S2 button is pressed, a timer interrupt is used for debouncing

//Currently the D2 LED is setup as a debug LED that should toggle whenever the button state changes
//Based on D2's behavior it does not seem like the mistoggling issue is hardware related but rather something to do with debouncing code

#include <msp430.h>

#define DEBUG BIT2

#define BUTTON BIT1
#define LED BIT7
volatile unsigned int uiTimerTick = 0;                  //Timer counter
unsigned char prevState;

// The board uses Pull Down resistors for the buttons, When buttons are NOT pressed the resistor 'pulls down' the pin to 0.
// When button is pressed the pin is connected to voltage which results in the pin being set to 1

// Timer A1
void setupTimerA1(void)
{
    // Configure DCO to 8 MHz
    BCSCTL1 |= CALBC1_8MHZ;
    DCOCTL |= CALDCO_8MHZ;

    TA1CCR0 = 400;                       // Timer period register,   400 / 8MHZ = 50us
    TA1CTL |= (TASSEL_2 + TACLR + MC_1); // SMCLK, count-up mode
    TA1CCTL0 |= CCIE;                    // Enable Timer1_A2 CCR0 interrupt
    __bis_SR_register(GIE);
}

// TA1CCR0 Register Interrupt
#pragma vector=TIMER1_A0_VECTOR
__interrupt void Timer1_A0 (void)
{
    uiTimerTick++;  // Interrupt counter, each 'tick'/increment represents 50us
}

void debounce()
{
    static unsigned int uiLastTick = 0; // Timer counter to compare against uiTimerTick for waiting
    unsigned char currState = (P2IN & BUTTON);      // Current state of button
    if(currState != prevState)                      // If the button state has changed
    {
       P1OUT ^= DEBUG;                              // Debugging, led flash when state changes
       if(currState == BUTTON)                      // If button is pressed
       {
           if ((uiTimerTick - uiLastTick) >= 200)   // 200 ticks of 50us = 10ms debounce time
           {
               P1OUT ^= LED;                        // Toggle LED
               uiLastTick = uiTimerTick;
           }
       }
       prevState = currState;
    }
}

void main(void)
{
    /*Debugging, Uses D2 to track the button changing states */
    P3DIR |= BIT3;
    P3OUT |= BIT3;
    P1DIR |= DEBUG;
    P1OUT &= ~DEBUG;
    /**/

    WDTCTL = WDTPW + WDTHOLD;
    setupTimerA1();
    P1DIR |= LED;                               // Set LED pin as an output
    P1OUT &= ~LED;                              // Initial state off

    P2DIR &= ~BUTTON;                           // Set BUTTON pin as an input
    prevState = (P2IN & BUTTON);  // State the button was just in
    while(1)
    {
        debounce();
    }
}

/*  Toggling done with interrupts, no debouncing
    #include <msp430.h>

    #define BUTTON BIT1
    #define LED BIT7

    // The board uses Pull Down resistors for the buttons, When buttons are NOT pressed the resistor 'pulls down' the pin to 0.
    // When button is pressed the pin is connected to voltage which results in the pin being set to 1

    void main(void)
    {
        WDTCTL = WDTPW + WDTHOLD; // Stop watchdog timer

        P1DIR |= LED; // Set P1.7 to output direction
        P2OUT &= ~BUTTON; // Set P2.1 to 0 because we are using pull-down resistors, will be set to 1 when button is pressed
        //P2REN |= BUTTON; // Enable P2.1 internal resistance

        P2IE |= BUTTON; // P2.1 interrupt enabled
        P2IES &= ~BUTTON; // P2.1 interrupt is triggered on the low to high transition
        P2IFG &= ~BUTTON; // P2.1 IFG cleared
        __bis_SR_register(GIE);
    }

    // Port 2 interrupt service routine
    #pragma vector=PORT2_VECTOR
    __interrupt void Port_2(void)
    {
     P1OUT ^= LED; // P1.0 = toggle
     P2IFG &= ~BUTTON; // P2.1 IFG cleared
    }
*/



