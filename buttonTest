// Ethan Van Deusen
// Button and debouncing test program

// The code should toggle the D6 LED when the S2 button is pressed, a timer interrupt is used for debouncing

// The board uses Pull Down resistors for the buttons, When buttons are NOT pressed the resistor 'pulls down' the pin to 0.
// When button is pressed the pin is connected to voltage which results in the pin being set to 1

#include <msp430.h>

#define DEBUG BIT2
#define TOGGLE_BUTTON BIT1
#define LED BIT7

#define HELD_TIME 40000                 // 2 Sec
#define DEBOUNCE_TIME 1000              // 50 mS
volatile unsigned int uiTimerTick = 0;  // Timer counter

typedef enum
{
    idle,
    pressed,
    released,
} DebounceState;

volatile static DebounceState debounceState = idle;      //Variable called 'debounceState' of type 'DebounceState' used for reading button presses

// Timer A1
void setupTimerA1(void)
{
    // Configure DCO to 8 MHz
    BCSCTL1 |= CALBC1_8MHZ;
    DCOCTL |= CALDCO_8MHZ;

    TA1CCR0 = 400;                       // Timer period register,   400 / 8MHZ = 50us
    TA1CTL |= (TASSEL_2 + TACLR + MC_1); // SMCLK, count-up mode
    TA1CCTL0 |= CCIE;                    // Enable Timer1_A2 CCR0 interrupt
    __bis_SR_register(GIE);
}

// TA1CCR0 Register Interrupt
#pragma vector=TIMER1_A0_VECTOR
__interrupt void Timer1_A0 (void)
{
    uiTimerTick++;  // Interrupt counter, each 'tick'/increment represents 50us
}

void debounce()
{
    static unsigned int uiLastTick = 0;
    unsigned char currS2State = (P2IN & TOGGLE_BUTTON);

    switch(debounceState)
    {
        case (idle):
            if(currS2State == TOGGLE_BUTTON)
            {
                debounceState = pressed;        // Transition to Pressed state
                uiLastTick = uiTimerTick;
            }
            break;
        case (pressed):
            if(currS2State == TOGGLE_BUTTON)
            {
                if ((uiTimerTick - uiLastTick) >= DEBOUNCE_TIME)
                {
                    P1OUT ^= LED;               // Toggle LED
                    debounceState = released;   // Transition to Released state
                }
//                Start of button held functionality, Should toggle blue LED after button is held for 2 seconds
//                if ((uiTimerTick - uiLastTick) >= HELD_TIME)
//                {
//                    P1OUT ^= DEBUG;                              // Debugging, led flash when state changes
//                    debounceState = released;   // Transition to Released state
//                }
            }
            else                                // If button has been released before debounce timer
            {
                debounceState = idle;           // Transition back to Idle state
            }
            break;
        case (released):
            if(currS2State != TOGGLE_BUTTON)
            {
                debounceState = idle;           // Transition back to Idle state
            }
            break;
    }
}

void main(void)
{
    /*Debugging, Sets up D2 for testing if needed */
    P3DIR |= BIT3;
    P3OUT |= BIT3;
    P1DIR |= DEBUG;
    P1OUT &= ~DEBUG;
    /**/

    WDTCTL = WDTPW + WDTHOLD;
    setupTimerA1();
    P1DIR |= LED;
    P1OUT &= ~LED;              // Initial state off
    P2DIR &= ~TOGGLE_BUTTON;    // Set BUTTON pin as an input
    while(1)
    {
        debounce();
    }
}

/*  Toggling done with interrupts, no debouncing    3/4/24
    #include <msp430.h>

    #define BUTTON BIT1
    #define LED BIT7

    // The board uses Pull Down resistors for the buttons, When buttons are NOT pressed the resistor 'pulls down' the pin to 0.
    // When button is pressed the pin is connected to voltage which results in the pin being set to 1

    void main(void)
    {
        WDTCTL = WDTPW + WDTHOLD; // Stop watchdog timer

        P1DIR |= LED; // Set P1.7 to output direction
        P2OUT &= ~BUTTON; // Set P2.1 to 0 because we are using pull-down resistors, will be set to 1 when button is pressed
        //P2REN |= BUTTON; // Enable P2.1 internal resistance

        P2IE |= BUTTON; // P2.1 interrupt enabled
        P2IES &= ~BUTTON; // P2.1 interrupt is triggered on the low to high transition
        P2IFG &= ~BUTTON; // P2.1 IFG cleared
        __bis_SR_register(GIE);
    }

    // Port 2 interrupt service routine
    #pragma vector=PORT2_VECTOR
    __interrupt void Port_2(void)
    {
     P1OUT ^= LED; // P1.0 = toggle
     P2IFG &= ~BUTTON; // P2.1 IFG cleared
    }
*/



